# need to make sure the truck travels at a stable speed as well
# will check this though
#### library ####
library(tidyverse)
#### setup ####
# first, setup a standard monitor
x_res <- 1920
Hz <- c(30, 60)
# how long is 100 frames at 60Hz
target_frames <- 100
target_time <- 1/60*target_frames
# how many frames are needed at 30Hz
frames <- Hz*target_time
# deltas
delta_min <- 200
delta_max <- x_res/2 -100
delta_steps <- round(delta_max - delta_min)/3
delta_list <- seq(delta_min, delta_max, delta_steps)
# probably want to put all this info into a data frame
setup <- tibble(x_width = rep(x_res, each = length(delta_list)*length(Hz)),
frame_rate = rep(Hz, each = length(delta_list)),
target_time = rep(1/60*target_frames, each = length(delta_list)*length(Hz)),
frames = frame_rate*target_time,
reach = rep(45, length(delta_list)*length(Hz)),
ratio_60 = frame_rate/60,
delta_list = rep(delta_list, length(Hz)),
max_speed = ceiling(max(delta_list)/frames) - 1/ratio_60)
#### do simulation ####
# need to sim for all possible Hz we have
# this gives us an idea of how things will look...
# need to remember that the more spread out distribution isn't
# really that spread... it just looks it since the speeds have a
# larger range, but they will be based on the speeds at 60Hz
# and therefore the spread actually remains the same
x <- seq(0,1,0.01)
max_speed <- unique(setup$max_speed)
beta_1 <- 1
beta_2 <- 1
# setup data frame
beta_frame <- data.frame(iter = numeric(),
frame_rate = numeric(),
delta = numeric(),
speed = numeric(),
end_dist = numeric(),
success = numeric())
for(Hz in unique(setup$frame_rate)){
# extract values
travel_time <- unique(setup$frames[setup$frame_rate == Hz])
max_speed <- unique(setup$max_speed[setup$frame_rate == Hz])
constant <- 1/unique(setup$ratio_60[setup$frame_rate == Hz])
reach <- unique(setup$reach[setup$frame_rate == Hz])
# run sims
for(delta in delta_list){
for(iter in 1:1000){
# first get a speed
speed <- ((rbeta(1, beta_1, beta_2)*max_speed)/constant)*
constant + constant
if(max_speed %% 2 == 0){
speed <- round(speed)
} else {
if(speed < max_speed/2 + 1){
speed = ceiling(speed)
} else {
speed = round(speed)
}
}
# get dist travelled
end_dist <- speed*travel_time + reach
success <- 0
if(end_dist >= delta){
success <- 1
end_dist <- delta
}
# add to dataframe
beta_frame <- rbind(beta_frame, data.frame(iter = iter,
frame_rate = Hz,
delta = delta,
speed = speed,
end_dist = end_dist,
success = success))
}
}
}
# check data
beta_frame %>%
filter(frame_rate == 60) %>%
group_by(delta) %>%
summarise(success = mean(success)) %>%
ggplot(aes(delta,success)) + geom_line() +
geom_vline(xintercept = c(delta_list),
linetype = "dashed") +
scale_x_continuous(breaks = c(0,200,400,600,800)) +
scale_y_continuous(limits = c(0,1),
breaks = seq(0,1,.25))
# plot
beta_frame %>%
filter(frame_rate == 60) %>%
mutate(norm_dist = end_dist/delta) %>%
ggplot(aes(norm_dist)) +
geom_histogram(position = "dodge",
aes(y = ..density..)) +
facet_wrap(~delta) + #, scales = "free") +
see::scale_color_flat() +
see::scale_fill_flat()
#### Accounting for RT delay ####
x_vals <- seq(0,target_frames,.2)
y <- dlnorm(x_vals,3,0.15)
# plot(x_vals, y)
# try using retimes to fit another curve
y <- retimes::dexgauss(x_vals, 20, 5)
plot(x_vals*0.0167, y)
# use inverse gaussian?
# some checks
mu = 25
shape = 33
x_vals <- seq(0,target_frames,0.01)
y <- brms::dinv_gaussian(x_vals, mu = mu, shape = shape)
plot(x_vals*0.0167,y)
# sim some values and get some meausres
check <- tibble(rt = brms::rinv_gaussian(1000, mu = mu, shape = shape)*0.0167,
iter = seq(1,1000,1))
mean(check$rt)
median(check$rt)
check %>%
mutate(med = median(rt),
mean_rt = mean(rt)) %>%
ggplot(aes(rt/0.0167)) +
geom_histogram(binwidth = 1)
# loop through with a "randomly" selected delay
setup_2 <- setup %>%
filter(frame_rate == 60)
setup_2 <- setup_2 %>%
rbind(setup_2) %>%
mutate(group = rep(c("Random", "Constant"), each = length(x_width)/2),
beta = rep(c(1, 1000), each = length(x_width)/2))
travel_time <- unique(setup_2$frames) + round(mean(check$rt)/0.0167)
max_speed <- unique(setup_2$max_speed)
constant <- 1/unique(setup_2$ratio_60)
reach <- unique(setup_2$reach)
# setup data frame to store results
beta_frame_2 <- data.frame(iter = numeric(),
beta = numeric(),
group = character(),
RT = numeric(),
delta = numeric(),
end_dist = numeric(),
speed = numeric(),
success = numeric())
for(g in unique(setup_2$group)){
beta1 = unique(setup_2$beta[setup_2$group == g])
beta2 = beta1
for(delta in unique(setup_2$delta_list)){
print(delta)
for(iter in 1:1000){
print(paste(iter, "/1000", sep = ""))
# get a response time
# RT <- round(retimes::rexgauss(1, 20, 5))
RT <- round(brms::rinv_gaussian(1, mu = mu, shape = shape))
# get speed
speed <- ((rbeta(1, beta1, beta2)*max_speed)/constant)*
constant + constant
if(max_speed %% 2 == 0){
speed <- round(speed)
} else {
if(speed < max_speed/2 + 1){
speed = ceiling(speed)
} else {
speed = round(speed)
}
}
# get dist travelled
end_dist <- speed*(travel_time-RT) + reach
success <- 0
if(end_dist >= delta){
success <- 1
end_dist <- delta
} else if(end_dist <= 0) {
success <- 0
end_dist <- 0
}
# add to dataframe
beta_frame_2 <- rbind(beta_frame_2, data.frame(iter = iter,
beta = beta1,
group = g,
RT = RT,
delta = delta,
end_dist = end_dist,
speed = speed,
success = success))
}
}
}
# plot this
beta_frame_2 %>%
mutate(norm_dist = end_dist/delta,
delta = as.factor(delta)) %>%
ggplot(aes(norm_dist, colour = group, fill = group)) +
geom_histogram(position = "dodge") +
see::scale_color_flat() +
see::scale_fill_flat() +
facet_wrap(~delta)#, scales = "free_y")
# overall accuracy?
plot_beta <- beta_frame_2 %>%
group_by(group) %>%
summarise(mu = mean(success),
n = n(),
alpha = sum(success),
beta = n-alpha)
merge(plot_beta, tibble(x = seq(0,1,.01))) %>%
mutate(y = dbeta(x, alpha, beta)) %>%
ggplot(aes(x, y,
colour = group)) +
geom_line() +
see::scale_color_flat()
View(plot_beta)
beta_frame_2 %>%
group_by(delta, group) %>%
# summarise(acc = mean(success)) %>%
mutate(acc = mean(success)) %>%
ggplot(aes(delta, acc, colour = group)) +
geom_line() +
geom_vline(xintercept = c(delta_list),
linetype = "dashed") +
scale_y_continuous(limits = c(0,1),
breaks = seq(0,1,.25)) +
see::scale_color_flat()
3*(mu/shape)^(1/2)
(15*mu)/shape
check <- tibble(rt = brms::rinv_gaussian(1000, mu = mu, shape = shape)*0.0167 + 0.2,
iter = seq(1,1000,1))
mean(check$rt)
median(check$rt)
# sim some values and get some meausres
check <- tibble(rt = brms::rinv_gaussian(1000, mu = mu, shape = shape)*0.0167,# + 0.2,
iter = seq(1,1000,1))
mean(check$rt)
median(check$rt)
shifted_wald <- function(x, lambda, alpha, omega){
y <- a/(sqrt((2*phi)*(x-omega)^3)) * exp((-(a-(lambda*(x - omega))^2))/(2*(x - omega)))
}
y = shifted_wald(seq(0,10,0.2), 2, 2, 2)
shifted_wald <- function(x, lambda, alpha, omega){
y <- alpha/(sqrt((2*phi)*(x-omega)^3)) * exp((-(alpha-(lambda*(x - omega))^2))/(2*(x - omega)))
}
y = shifted_wald(seq(0,10,0.2), 2, 2, 2)
pi
shifted_wald <- function(x, lambda, alpha, omega){
y <- alpha/(sqrt((2*pi)*(x-omega)^3)) * exp((-(alpha-(lambda*(x - omega))^2))/(2*(x - omega)))
}
pi
y = shifted_wald(seq(0,10,0.2), 2, 2, 2)
# school visit
#### Packages ####
library(tidyverse)
#### functions ####
get_feet <- function(value){
feet = floor(value)
inches = round((value - feet)*12)
results = list("feet" = feet, "inches" = inches)
return(results)
}
get_feet_inches <- function(feet, inches){
output = round(feet + (inches/12), digits = 2)
}
#### Input data ####
# get distances
Distances <- c(3,6,10,15,22,30,38)
# Input accuracy same format as above
# example: c(12,10,8,6,2,2,2,1)
P1 <- c(6,c(4,6,0,1,1),0)
P2 <- c(6,c(6,3,5,0,0),0)
P3 <- c(6,c(6,5,2,1,1),0)
# setup data frame
df <- tibble(Person = rep(c("P1", "P2", "P3"), each = length(Distances)),
Distance = rep(Distances, 3),
inHoop = c(P1, P2, P3)) %>%
mutate(Accuracy = inHoop/6,
Person = as.factor(Person))
# tidy
rm(Distances, P1, P2, P3)
#### run glm ####
# get accuracy for various distances
acc_seps <- data.frame(Person = factor(),
Distance = numeric(),
Acc = numeric())
# for swapping point
Fifty <- data.frame(Person = factor(),
position = numeric(),
acc = numeric())
# list of separations
seps <- seq(0, 38, .01)
# loop through participants
for(sub in unique(df$Person)){
# get subset
ss <- df[df$Person == sub,]
# run model
m <- glm(data = ss, Accuracy~Distance,
family = binomial)
# get predictions
p = predict(m, data.frame(Distance = seps), type = "response")
p = round(as.numeric(p), digits = 3)
# add to frame
acc_seps <- rbind(acc_seps, data.frame(Person = sub,
Distance = seps,
Acc = p))
# get 50% point
Est <- which(abs(p-.5)==min(abs(p-.5)))
Fifty <- rbind(Fifty, data.frame(Person = sub,
position = seps[Est],
acc = p[Est]))
}
# acc_seps overall
# model
m <- glm(data = df, Accuracy ~ Distance,
family = binomial)
# get new accseps
p <- predict(m, data.frame(Distance = seps), type = "response")
acc_seps_overall <- data.frame(Distance = seps,
Accuracy = p)
Est <- which(abs(p-.5)==min(abs(p-.5)))
Fifty_overall <- data.frame(position = seps[Est],
acc = p[Est])
# maybe a plot here?
df %>%
ggplot(aes(Distance, Accuracy)) +
geom_point() +
theme_bw() +
scale_y_continuous(labels = scales::percent_format(accuracy = 1))
df %>%
ggplot(aes(Distance, Accuracy)) +
# geom_point() +
geom_smooth(colour = "black",
method = glm,
method.args = list(family = "binomial"),
se = F, fullrange = T) +
theme_bw() +
geom_point() +
scale_y_continuous(labels = scales::percent_format(accuracy = 1))
# sort out label
# geom_text(data = Fifty_overall,
#           nudge_x = -1.6,
#           nudge_y = -0.03,
#           aes(position, acc,
#               label = paste(get_feet(position)$feet, "`",
#                             get_feet(position)$inches, "''")))
plt_avg <- df %>%
ggplot(aes(Distance, Accuracy)) +
geom_smooth(colour = "black",
method = glm,
method.args = list(family = "binomial"),
se = F, fullrange = T) +
theme_bw() +
geom_segment(data = Fifty_overall,
aes(x = position, y = 0,
xend = position, yend = acc),
linetype = 1) +
geom_segment(data = Fifty_overall,
aes(x = 0, y = acc,
xend = position, yend = acc),
linetype = 1) +
scale_y_continuous(labels = scales::percent_format(accuracy = 1))
plt_avg$labels$x <- "Distance (feet)"
# tidy
rm(m, ss, Est, p, seps, sub)
#### make plot ####
plt1 <- df %>%
ggplot(aes(Distance, Accuracy, colour = Person)) +
# geom_point() +
geom_smooth(#colour = "black",
method = glm,
method.args = list(family = "binomial"),
se = F,
fullrange = T) +
facet_wrap(~Person) +
see::scale_color_flat() +
theme_bw() +
theme(legend.position = "none",
strip.text.x = element_blank()) +
scale_y_continuous(labels = scales::percent_format(accuracy = 1)) #+
# coord_cartesian(expand = F)
plt1$labels$x <- "Distance (feet)"
plt1 + geom_point()
### Add line to show the Fifty percent point ####
plt2 <- plt1 +
geom_segment(data = Fifty,
aes(x = position, y = 0,
xend = position, yend = acc),
linetype = 1) +
geom_segment(data = Fifty,
aes(x = 0, y = acc,
xend = position, yend = acc),
linetype = 1)
plt2
#### get choices ####
P1 <- 20
P2 <- 8
P3 <- 30
# choices for everyone
num_subs <- 20
choices <- c(round(rnorm(num_subs/2, Fifty$position, 2)), round(rnorm(num_subs/2, 4, 2)))
demo_version <- tibble(Person = seq(1,num_subs,1),
Group = rep(c("Achievement", "Accuracy"), each = num_subs/2),
Distance = choices)
# add in expected accuracy
demo <- merge(demo_version, acc_seps_overall)
# plot
plt_avg +
geom_segment(data = demo,
aes(x = Distance, y = 0,
xend = Distance, yend = Accuracy,
colour = Group),
linetype = 1,
size = 1.2,
alpha = 1) +
geom_segment(data = demo,
aes(x = 0, y = Accuracy,
xend = Distance, yend = Accuracy,
colour = Group),
linetype = 1,
size = 1.2,
alpha = 1) +
see::scale_color_flat()
demo %>%
ggplot(aes(Distance, colour = Group, fill = Group)) +
geom_histogram(binwidth = 1, position = "dodge")+
see::scale_color_flat() +
see::scale_fill_flat() +
theme_bw()
demo %>%
ggplot(aes(Distance, colour = Group, fill = Group)) +
geom_density(alpha = .3) +
see::scale_color_flat() +
see::scale_fill_flat() +
theme_bw()
#### ENTER IN CHOICES FOR EVERYONE ####
# num_subs <- 20
choices <- c(P1, P2, P3, 1, 20,
7, 8, 7, 20, 15,
14, 20, 8, 6, 1,
13, 13, 1, 12, 24)
num_subs <- length(choices)
df_choices_overall <- tibble(Person = seq(1,num_subs,1),
Group = rep(c("Achievement", "Accuracy"), num_subs/2),
Distance = choices)
# add in expected accuracy
df_choices_overall <- merge(df_choices_overall, acc_seps_overall)
plt_avg1 <- plt_avg +
geom_segment(data = df_choices_overall,
aes(x = Distance, y = 0,
xend = Distance, yend = Accuracy,
colour = Group),
linetype = 1) +
geom_segment(data = df_choices_overall,
aes(x = 0, y = Accuracy,
xend = Distance, yend = Accuracy,
colour = Group),
linetype = 1) +
see::scale_color_flat()
plt_avg1
plt_avg2 <- df_choices_overall %>%
ggplot(aes(Distance, colour = Group, fill = Group)) +
# geom_density(alpha = 0.3) +
geom_histogram(position = "dodge") +
see::scale_color_flat() +
see::scale_fill_flat() +
theme_bw()
plt_avg2
head(plt_avg[["data"]])
head(plt_avg2[["data"]])
head(df_choices_overall)
df_choices_overall %>% group_by(Group) %>% summarise(mu = mean(Distance))
df_choices_overall %>% group_by(Group) %>% summarise(mu = mean(Distance), sig = sd(Distance))
t.test(df_choices_overall$Distance ~ df_choices_overall$Group)
View(df_choices_overall)
x_vals <- seq(0,1,0.01)
y <- dbeta(x_vals, 1, 1)
plot(x,y)
plot(x_vals,y)
y <- dbeta(x_vals, 2, 2)
plot(x_vals,y)
0.*8
0.2*8
y <- dbeta(x_vals, 10000, 10000)
plot(x_vals,y)
x_vals <- seq(0,1,0.001)
y <- dbeta(x_vals, 10000, 10000)
plot(x_vals,y)
for(i in 1:100){
print(i)
}
for(i in 1:100){
print(i + 5)
}
test <- function(a, b){
output <- a + b
}
test(1,2)
test <- function(a, b){
output <- a + b
return(output)
}
test(1,2)
setwd("F:/Uni/PhD/3rd year/Experiments/Achievement")
#### sampling to find N ####
# Want to loop through each group
# Select N samples (with replacement)
# Get the mean
# plot these means...
#### Library ####
library(tidyverse)
#### read in data ####
df_choices_overall <- read.csv("data/Pilot/Pilot_data.txt")
